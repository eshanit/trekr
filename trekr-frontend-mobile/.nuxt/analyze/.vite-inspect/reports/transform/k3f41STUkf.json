{
  "resolvedId": "C:/Users/Admin/Documents/Projects/Tinashe/trekr/trekr-frontend/node_modules/@ionic/core/components/notch-controller.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index5.js';\nimport { r as raf } from './helpers.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n  let notchVisibilityIO;\n  const needsExplicitNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (\n    /**\n     * If the notch is not being used\n     * then we do not need to set the notch width.\n     */\n    notchSpacerEl === undefined ||\n      /**\n       * If either the label property is being\n       * used or the label slot is not defined,\n       * then we do not need to estimate the notch width.\n       */\n      el.label !== undefined ||\n      getLabelSlot() === null) {\n      return false;\n    }\n    return true;\n  };\n  const calculateNotchWidth = () => {\n    if (needsExplicitNotchWidth()) {\n      /**\n       * Run this the frame after\n       * the browser has re-painted the host element.\n       * Otherwise, the label element may have a width\n       * of 0 and the IntersectionObserver will be used.\n       */\n      raf(() => {\n        setNotchWidth();\n      });\n    }\n  };\n  /**\n   * When using a label prop we can render\n   * the label value inside of the notch and\n   * let the browser calculate the size of the notch.\n   * However, we cannot render the label slot in multiple\n   * places so we need to manually calculate the notch dimension\n   * based on the size of the slotted content.\n   *\n   * This function should only be used to set the notch width\n   * on slotted label content. The notch width for label prop\n   * content is automatically calculated based on the\n   * intrinsic size of the label text.\n   */\n  const setNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (notchSpacerEl === undefined) {\n      return;\n    }\n    if (!needsExplicitNotchWidth()) {\n      notchSpacerEl.style.removeProperty('width');\n      return;\n    }\n    const width = getLabelSlot().scrollWidth;\n    if (\n    /**\n     * If the computed width of the label is 0\n     * and notchSpacerEl's offsetParent is null\n     * then that means the element is hidden.\n     * As a result, we need to wait for the element\n     * to become visible before setting the notch width.\n     *\n     * We do not check el.offsetParent because\n     * that can be null if the host element has\n     * position: fixed applied to it.\n     * notchSpacerEl does not have position: fixed.\n     */\n    width === 0 &&\n      notchSpacerEl.offsetParent === null &&\n      win !== undefined &&\n      'IntersectionObserver' in win) {\n      /**\n       * If there is an IO already attached\n       * then that will update the notch\n       * once the element becomes visible.\n       * As a result, there is no need to create\n       * another one.\n       */\n      if (notchVisibilityIO !== undefined) {\n        return;\n      }\n      const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n        /**\n         * If the element is visible then we\n         * can try setting the notch width again.\n         */\n        if (ev[0].intersectionRatio === 1) {\n          setNotchWidth();\n          io.disconnect();\n          notchVisibilityIO = undefined;\n        }\n      }, \n      /**\n       * Set the root to be the host element\n       * This causes the IO callback\n       * to be fired in WebKit as soon as the element\n       * is visible. If we used the default root value\n       * then WebKit would only fire the IO callback\n       * after any animations (such as a modal transition)\n       * finished, and there would potentially be a flicker.\n       */\n      { threshold: 0.01, root: el }));\n      io.observe(notchSpacerEl);\n      return;\n    }\n    /**\n     * If the element is visible then we can set the notch width.\n     * The notch is only visible when the label is scaled,\n     * which is why we multiply the width by 0.75 as this is\n     * the same amount the label element is scaled by in the host CSS.\n     * (See $form-control-label-stacked-scale in ionic.globals.scss).\n     */\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n  };\n  const destroy = () => {\n    if (notchVisibilityIO) {\n      notchVisibilityIO.disconnect();\n      notchVisibilityIO = undefined;\n    }\n  };\n  return {\n    calculateNotchWidth,\n    destroy,\n  };\n};\n\nexport { createNotchController as c };\n",
      "start": 1700143042175,
      "end": 1700143042329,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1700143042329,
      "end": 1700143042329,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1700143042329,
      "end": 1700143042330,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1700143042330,
      "end": 1700143042330,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1700143042330,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1700143042331,
      "end": 1700143042331,
      "order": "normal"
    }
  ]
}
